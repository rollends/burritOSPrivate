\documentclass[twoside,a4paper]{refart}
\usepackage{makeidx}
\usepackage{ifthen}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\def\bs{\char'134 }
\newcommand{\ie}{i.\,e.,}
\newcommand{\eg}{e.\,g..}
\DeclareRobustCommand\cs[1]{\texttt{\char`\\#1}}
\settextfraction{0.9}
\setlength\parskip {0.15in}

\title{burritOS System Manual}
\author{Rollen D'Souza (20418141) \\
rs2dsouz@uwaterloo.ca \\
Taylor Petrick (20413951) \\
tpetrick@uwaterloo.ca \\}

\date{\textbf{CS 452 - Real Time With Bill Cowan \\ Final Project \\ \today}}
\emergencystretch1em  %

\pagestyle{myfootings}
\markboth{burritOS System Manual}%
         {burritOS System Manual}

\makeindex
\setcounter{tocdepth}{2}
\begin{document}
\maketitle


\textbf{Noteworthy Changes}\\\\
A collection of new debugging and utility system calls were added, including calls for querying the PC, LR, and stack details of running tasks.\\

Several new UI tasks were added to assist with debugging system state. A \textit{Stack State} task was added to display the number of free memory blocks, and the stack usage of each task. A \textit{Process State} task was added to display the task id, state, send queue length and stack summary for each task in the system. Finally, a new logging system was added to allow tasks to log to a rolling buffer. A \textit{Log Server} display task was added that displays the contents of the buffer.\\

The project implementation was also added, including a display task to show project state. A new command, \textit{lg [id]}, was added to configure a given train for use with the project.

\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compiling and Running}
A compiled version of our Trains 1 submission can be found in the following directory on the student environment:
\begin{center}
\textit{/u/cs452/tftp/ARM/tpetrick/p1.elf}\\
\textit{md5 hash: ?}
\end{center}
The source code for our submission has been shared with the CS 452 TA via the UW GitLab, and can be accessed at the following URL:
\begin{center}
\url{https://git.uwaterloo.ca/tpetrick/CS452_Project}\\
\textit{md5 hash: ?}
\end{center}
Additionally, the course code can also be downloaded as an archive from Taylor’s personal web server:
\begin{center}
\url{https://www.taylorpetrick.com/cs452/p1.tar.gz}\\
\textit{md5 hash: ?}
\end{center}
Both source code locations contain the files listed in the File Listings section of this report.

To compile the source code, simply run \textit{make} in the top level source directory. This will produce the binary file \textit{/bin/p1.elf}, which should be identical to the elf file listed above. Running \textit{make clean} will remove all build output files, and \textit{make doc} will generate documentation from the source files if Doxygen is installed on the system.

By default, code is built using a unity build technique. The makefile runs \textit{cat} on all of the source files to produce a single source file, which is then built with GCC. This can be disabled by passing \textit{UNITY=0} when running \textit{make}.

The file can be loaded and run on the TS7200 board with the following Redboot commands:

\textit{\textgreater load -b 0x50000 -h 10.15.167.5 /u/cs452/tftp/ARM/tpetrick/p1.elf}\\
\textit{\textgreater go}\\\\

\textbf{CAUTION:}  The load address has changed since our past submissions. We no longer use the default address of \textit{0x218000}, and require that code is loaded at \textit{0x50000} instead. This should be handled automatically by the linker script and \textit{.elf} file, however it may be necessary to specify the \textit{-b} parameter when loading to Redboot.

\section{Hardware Interface}
\subsection{General Notes and Usage}
The hardware layer is intended to abstract away the details of dealing with hardware perhipherals. It current wraps the timers, UARTS and interrupt controller logic in a simple interace. An implementation of the interface for the TS7200 board can be found in the \textit{hardware/ts7200} subdirectory.

The hardware layer is also responsible for providing instructions for intializing the interrupt vector table, and handling software and hardware interrupts.

\subsection{Interrupt Driven I/O}
The \textit{sysWrite} call takes a UART port and character as parameters and blocks the calling task until a transmit interrupt occurs. Since transmit interrupts continuously fire until a byte is transmitted, we disable the interrupt on the UART after transmitting a byte. \textit{sysWrite} also enables the TX interrupt so the task will be able to send data.

A \textit{sysRead} call is also provided for reading from a serial port. The call takes a UART port as its only parameter and returns a byte once an RX interrupt occurs on the desired UART. Technically sysRead could be implemented using the existing \textit{sysAwait}, however we chose to make a separate system call for readability and API consistency. Initially we also experimented with buffering input in the kernel, which required special read/write logic - the names \textit{sysRead}/\textit{sysWrite} calls are leftover from that implementation.

When using UART 1 the CTS flag is checked before transmitting data. This is done by handling the ORed interrupt for UART 1, which includes RX, TX and modem status interrupts. When a UART 1 interrupt occurs we first determine which source (RX, TX, Modem) it is by reading the UART’s IRQ status register. If a modem status interrupt is triggered, the interrupt handler queries the UART’s CTS register and updates the kernel’s CTS flag. If the interrupt is an RX or TX interrupt, the event table is checked to see if any tasks are waiting to read or write from UART 1. TX interrupts are only processed for UART 1 if the CTS flag is set to 1 UART 2 does not require a CTS flag, so the ORed interrupt trigger isn’t used. The event handler processes the raw TX and RX interrupts for that UART in the same way that the timer events are handled.

\section{Kernel Design}

\subsection{Memory Layout}
Task stacks are placed at address \textit{0x01000000} and higher. Task stacks are created in 16kb blocks. The stacks are managed by a \textit{MemoryAllocator} that uses FIFO queues to give out and reclaim stack blocks. The first word on the stack is its block id; the remaining space is used by the task as desired. Storing the id to the stack serves a dual purpose - it makes reclaiming the stack easier, and also act as an indicator for stack overflows. A block id that seems corrupted when the stack is reclaimed by the allocator is a strong indication that a neighboring stack overflowed.

The system has more memory blocks that tasks, so the additional blocks can be access by tasks using the \textit{sysAlloc()} and \textit{sysFree()} calls. These methods also return \textit{16kb} blocks, and serve as a basic memory page allocator.

\subsection{Data Structures}
All data structures in our implementation fall into two categories: flat arrays and circular queues. The circular queues are implemented using a memory block, a length variable and head/tail indices indicating the start and end of the queue. The length and memory pointer are passed in when the queue is initialized. This allows the size of the queue to vary based on the context (e.g. small send queues but large ready queues). Our kernel requires that queues have a length that is equal to a power of two. This is to avoid using modulus function from libgcc. Instead, since the queues are a power of two in length, a bitwise \textit{and} can be used to ensure the queue indices wrap around to 0. For example:

\begin{verbatim}
    head = (head + 1) & (length - 1)
\end{verbatim}

The priority queue used for scheduling of ready tasks is a special data structure that contains a set of circular buffer queues. One queue is used for each of the priorities. Kernel 1 and 2 only used three priorities, however in Kernel 3 the number of priorities was increased to 32. A 32 bit integer is used to determine which queues have tasks in them. Bit twiddling is done to compute the highest priority queue with an element in it; the code to do this was taken from \url{https://graphics.stanford.edu/~seander/bithacks.html}. It emulates a count trailing zeroes (CTZ) instruction since ARM v4 lacks CTZ/CLZ.

TaskDescriptors (or otherwise known as TDs) contain the information the kernel needs to schedule tasks and perform system calls. Non essentially information such as the PC and SPSR are stored on the task stack. The kernel stores a TaskTable which has a fixed size array of task descriptors and queue of free descriptors. At the start of the kernel, all descriptors are in the free queue. When a task is created, it pops from the queue and uses the available task descriptor. When a task exits it returns the descriptor to the queue so it can be reused later on. A generation id is stored along with each task id, and gets incremented each time a task is reclaimed by the TaskTable. The TD recycling feature is not used for Kernel 1, but it is included in the code since we plan to build on it in future assignments

TDs themselves are designed to be tightly packed. Task priority is stored as a single byte rather than a full 32 bit value, for example. TaskIDs are 16 bit values, where the first byte is the generation number and second byte is the actual task id and index into the TaskDescriptor array. The task ids are one-based, since task 0 will eventually be used to identify the null task. At the moment, our kernel is defined to support a maximum of 64 tasks. It can support as many as 255 tasks and 255 generations, however it seems unlikely that we will come close to either of these values.

The last important data structure is the kernel data struct. Kernel data is stored as a global that is only used in  kernel functions (bootstrap, schedule and system call). It contains the task table, a pointer to the active task descriptor and the priority queue and queue data.

\subsection{Control Flow}
The bulk of the kernel logic is controlled in the assembly file \textit{kernel/start.s}. The kernel begins by initializes the interrupt vector table. It then calls the \textit{bootstrap()} function, which initializes all of the kernel data structures and creates the first user task. The user task is entered and runs until an SWI instruction is executed.

When a system call is made the program branches to the \textit{\_systemCall} label in \textit{kernel/start.s}. Since the \textit{SWI} call is wrapped in a C function, GCC automatically places the parameters into \textit{R0-R3} and onto the user stack. To minimize the amount of memory overhead, the system call is processed almost immediately after entering the SWI handler. This is done by calling \textit{systemCallHandler()}, which is performed in System Mode so the user stack is available. The return value from the function is stored in \textit{R0} by GCC. After the call completes the user registers are stacked, including the new \textit{R0} value. When the user task registers are unstacked the next time the task runs, the \textit{R0} value will be restored so the task can inspect the system call return value.

After stacking the registers the kernel calls \textit{schedule()} which updates the task descriptor of the current task, re-enqueues it if necessary and selects a new task from the priority queues. The new task’s stack pointer is returned and the task is entered, thus repeating the process. If the new stack pointer is 0 the kernel will branch to the \textit{kernelEnd} handler to perform cleanup and exit the program.

When an interrupt is fired the control flow is very similar. The interrupt causes the code to jump to the \textit{\_interruptCall} label, which is very similar to \textit{\_systemCall} discussed above. The primary difference is that the interrupt handler calls the  \textit{interruptHandler()} C function instead of processing a system call. The other functionality, such as stacking user registers and scheduling a new task, is the same.

It is worth noting that the task registers are stored in the following layout on the task stack:

\begin{verbatim}
    stack+0x0       SPSR
                    Task LR (R14)
                    R0
                    R4
                    ..
                    R12
    stack+0xA       Task PC (R15)
\end{verbatim}
This somewhat out-of-order stacking order was chosen to make the context switcher more compact.

\subsection{Event Handling}
The \textit{sysAwaitEvent(event)} primitive allows tasks to wait for interrupts. The supported events are defined in \textit{kernel/event.h}. The kernel data struct has a table that maps event types to the task ids waiting on the events. Only one task can wait on an event at a time, which we think will be sufficient for the remaining coursework.

When an interrupt occurs the system jumps to the label \textit{\_interruptCall}. This works much like the swi handler, however instead of calling the syscall function it calls \textit{interruptHandler()} to process the interrupt. The interrupt handler checks the event table to see if a task is waiting on the event. If a valid task id is found, the task is unblocked and the table entry cleared, otherwise the interrupt is consumed without taking any additional action. Like the swi handler, an interrupt results in a call to the scheduler after interrupt processing is complete.

\subsection{Message Passing}
Messages can be set between tasks using the \textit{sysSend} and \textit{sysReceive} system calls, both of which are blocking. After receiving a message a task must reply to its sender using the \textit{sysReply} primitive.

By default, no deep memory copies are done in the kernel. All messages are at most 1 word in length, however that word can be a pointer to a large buffer of memory if desired. When the kernel sends a message it copies the message type and the 1 word message body to the receiver’s message envelope. It is up to the receiving task to make a copy of the memory using the \_memcpy function. This design makes the kernel extremely lightweight, and also eliminates the need to do a memory copy if the message data is used in a read-only way. For safety reasons, this design is unsuitable for general purpose operating systems, but in a control RTOS it offers performance benefits.

For the performance benchmarks with 64 bytes a full memcpy is done upon receiving a message and after receiving a reply. The memcpy implementation was written from scratch and uses load/store multiple instructions to improve copying speed.

\subsection{Performance}
Performance timing is reset with a call to \textit{sysPerfReset()} - this sets all task performance counters to 0 and resets the timer used by the kernel to track performance. The kernel uses the 40-bit debug timer for this process since it’s clocked at around 983 Khz. This offers slightly better timer resolution that the standard 16 and 32 bit timers, which can only run at a max of 508 Khz.

Calling \textit{sysPerfQueryP(tid, mode)} will return the percentage of execution time spent on the task tid. The mode parameter can be \textit{ePerfKernel}, \textit{ePerfTask} or \textit{ePerfBoth}. Using \textit{ePerfKernel} returns the time spent by the task in the kernel, and \textit{ePerfTask} returns the time spent in task code. The \textit{ePerfBoth} option is useful be cause it adds the kernel and task performance together before computing the percentage - this yields slightly higher precision results in most cases since the numerator of the computation is larger.

The \textit{sysPerfQueryT(tid, mode)} system call queries the run time microseconds for each of the cases listed above, rather than as a relative percentage. Additionally the mode value ePerfTotal can be passed in to get the total run time in microseconds since the last call to \textit{sysPerfReset()}.

The performance timings are implemented by storing two unsigned integers at the end of each task descriptor. When a system call or interrupt occurs, the active task has its task mode counter updated by the current timer delta. Then, right before the scheduler returns, the last active task has its kernel mode counter updated by the timer delta. Both updates reset the timer delta. This means that task mode timings are the amount of time spent from the return statement of the scheduler until the entry point of a system call or interrupt, and kernel mode timings are the amount of time spent inside the syscall/interrupt and scheduler. This is not a perfect representation of task/kernel time, but is close enough to be useful.

The following output was produced using the data recored by the performance primitives:
\begin{verbatim}
    TaskId  Tsk %   Krnl %  Ttl %   Tsk us      Krnl us     Ttl us
    0x00    46.17   50.68   96.86   1,156,700   1,269,741   2,426,442
    0x01    00.26   00.00   00.26       6,623          64       6,687
    0x02    00.00   00.00   00.00          28          43          72
    0x03    00.03   00.05   00.10       1,053       1,509       2,563
    0x04    00.03   00.05   00.10       1,075       1,539       2,614
    0x05    01.21   00.00   01.22      30,915          91      31,012
    0x06    01.22   00.00   01.22      31,209         114      31,324
    0x07    00.55   00.00   00.55      14,049          57      14,107
    0x08    00.36   00.00   00.36       9,366          42       9,408
    0x09    00.17   00.00   00.17       4,691          26       4,718

    Total run time: 2,552,806us ~ 2.552s
\end{verbatim}

\section{System Calls}
\subsection{System State}

The \textit{System State} calls are used to monitor the state of the kernel. Currently there are two calls in this category.

\textbf{sysRunning(void)} - Returns 1 if the system running flag is set, else returns 0.\\\\
\textbf{sysShutdown(void)} - Sends a shutdown signal to the kernel, and sets the running state to 0. Does not force the system to terminate; tasks must check the running flag with \textit{sysRunning} to determine if they should continue executing.\\\\
\textbf{sysKill(void)} - Forces the system to shutdown and does not necessarily peform any clean up. Processes are not notified of the shutdown. This should only be used when the system is hung, as a last alternative to reseting the hardware itself.

\subsection{Task Management}

\textit{Task Management} system calls are used to create, destroy and query tasks. There are a total of 7 task related system calls.

\textbf{sysExit(void)} - Exits a task and returns the descriptor and stack back to the kernel. This system call is deprecated; tasks will perform this operation on their own once the task function returns.\\\\
\textbf{sysPass(void)} - Yields control of the processor to the kernel. Effective performs a no-op, however since the scheduler is invoked a different task may be entered.\\\\
\textbf{U16 = sysCreate(priority, entry\_point)} - Creates a new task with a given priority and code entry point. The new task's id is returned.\\\\
\textbf{char* = sysName(tid)} - Returns a pointer to the string name of a given task.\\\\
\textbf{U16 = sysTid(void)} - Returns the id of the current task.\\\\
\textbf{U16 = sysPid(void)} - Returns the id of the current task's parent.

\subsection{Task State}

\textit{Task State} system calls return state information about tasks in the systems.

\textbf{U8 = sysPriority(tid)} - Returns the priority of a given task.\\\\
\textbf{U8 = sysState(tid)} - Returns the state of a given task.

\subsection{Messaging}

\textit{Messaging} system calls are used to perform inter-task communication. Currently only blocking ITC is supported.

\textbf{sysSend(tid, *msg, *reply)} - Sends a message to task, and provides a memory location in which the reply should be stored. Blocks the caller until a \textit{sysReply} is sent by the receiver.\\\\
\textbf{sysReceive(*tid, *msg)} - Receives a message and stores the sender id and message body. Blocks the caller until a message arrives.\\\\
\textbf{sysReply(tid, *msg)} - Sends a reply message back in response to a \textit{sysReceive}.

\subsection{Performance}

The \textit{Performance} calls are used to monitor system performance. See \textbf{Section 4.6} for details on performance monitoring.

\textbf{sysPerfReset(void)} - Resets performance tracking on all tasks.\\\\
\textbf{U32 = sysPerfQueryP(tid, mode)} - Queries performance of task for a given mode, as a percentage of total runtime.\\\\
\textbf{U32 = sysPerfQueryT(tid, mode)} - Queries performance of task for a given mode, as an absolute time in microseconds.\\\\
\textbf{U32 = sysPerfQueryPC(tid)} - Returns the program counter of a given task.\\\\
\textbf{U32 = sysPerfQueryLR(tid)} - Returns the link register of a given task.\\\\
\textbf{U32 = sysPerfQuerySP(tid)} - Returns the current stack pointer of a given task.\\\\
\textbf{U32 = sysPerfQuerySB(tid)} - Returns the base stack pointer of a given task.\\\\
\textbf{U32 = sysPerfQuerySI(tid)} - Returns the stack block index of task.\\\\
\textbf{U8 = sysPerfCount(void)} - Queries the number of tasks currently running. \\\\
\textbf{U16 = sysPerfStackCount(void)} - Queries the number of available stack blocks in the system. \\\\
\textbf{U8 = sysPerfSendCount(tid)} - Queries the number of messages in a given tasks send queue.

\subsection{Event Handling and I/O}

\textit{Event} system calls are used to block on hardware interrupts and interact with hardware peripherals. See the \textbf{Section 2.2} for details on interrupt driven input and output. All Event calls cause tasks to be blocked on hardware interrupts.

\textbf{sysAwait(event)} - Blocks the calling task on a specific event.\\\\
\textbf{char = sysRead(port)} - Blocking read from a UART port.\\\\
\textbf{sysWrite(port, byte)} - Blocking write to a UART port.

\subsection{Memory}

The burritOS system does not use or provide heap allocation, however it does have a generic memory block allocator. The allocator is used to give out stack blocks; extra blocks are available via memory system calls. No protection or ownership verification is done on the blocks.

\textbf{U32* = sysAlloc(void)} - Returns a pointer to a 16kB - 1 word memory block. The first address holds the block id, so the memory returned begins after that location.\\\\
\textbf{sysFree(block*)} - Frees a memory block pointer for reuse by the system.

\section{Debugging and Assertions}
 Almost all hardware and kernel functions return a status code and perform safety checks including out-of-bounds access, invalid memory addresses and invalid parameter values. Assertions are used liberally to validate both kernel and user-space code. When an assertion is throw, a debug message is printed:

\begin{verbatim}
    ....................
    ....................
    ......______ .......
    ...../      \ \.....
    ..../  x  x  \n\....
    ...|   ____   hn|...
    ...|  /    \  hn|...
    ....\_________\/....
    ....................
    .....SAD..TACO......
    ....................

    Assertion in `kernel/scheduler.c` on line 18
    Current Active Task is 0x06
\end{verbatim}

Assertions, return codes and bounds checking can be enabled/disabled using a collection of preprocessor flags. When return codes are disabled functions return void, otherwise they return a signed integer. These flags are:\\
\begin{verbatim}
    NULL_CHECK              Include null pointer checks on memory address
    BOUNDS_CHECK            Include bounds checking
    RANGE_CHECK             Include memory address range checks
    DEVICE_CHECK            Include device register checks (e.g. UART, timers, etc)
    ASSERT_BUILD            Enabled assertions
    RETURN_CODES            Enable return codes
    KERNEL_PERF             Enable kernel performance primitives
    KERNEL_PERF_VERBOSE     Enable verbose performance updates from the perf Task
\end{verbatim}

These flags enable a set of error and assertion macros that are normally disabled. For example, for null checking:

\begin{verbatim}
    #ifdef NULL_CHECK
        #define IS_NOT_NULL(x) do {if ((x) == 0) return ERROR_NULL;} while(0);
    #else
        #define IS_NOT_NULL(x)
    #endif
\end{verbatim}

It is up to the kernel programmer to use the macros in their code, so we have not yet achieved full coverage. This is an area that will be improved in future iterations of the kernel.
\section{Userspace}
\subsection{Services}
The general purpose user-space tasks provide important services on top of the kernel. All of these tasks provide a named interface that can be discovered using the \textit{Name Server}. The \textit{Name Server} is assumed to be have a task ID of 2.

\subsubsection{Name Service}

\textbf{nsRegister(taskName)} - Registers the caller task with the name provided.\\\\
\textbf{nsWhoIs(taskName)} - Looks up the \verb~TaskID~ of the task registered with the provided name. Will block until \textit{all} task names have been registered.\\\\

The \textit{Name Server} task triages and responds to requests to find the task ID of a "named" task. Two service methods are provided as the interface to the name service. This service provides the ability for tasks to find other operating system services. The current implementation requires that all possible registrations be made before any lookup (WhoIs) requests are served. As a consequence of our kernel development tenets, we chose enumerated values to represent task names instead of strings. This reduces complexity in the user space code of the nameserver. An enumerated list has a well-defined maximum meaning the nameserver can maintain a constant-sized array to store registered IDs.

\subsubsection{Clock Service}

\textbf{clockDelayBy(clockServerID, ticks)} - Delays a task by \verb~ticks~ times 10 milliseconds. The delay is guaranteed to an interval of plus or minus 10 milliseconds.\\\\
\textbf{clockLongDelayBy(clockServerID, longTicks)} - Delays a task by \verb~longTicks~ times 150 milliseconds. The delay is guaranteed to an interval of plus or minus 150 milliseconds.\\\\
\textbf{clockTime(clockServerID)} - Returns the current time reported by the \textit{Clock Server}, in multiples of 10 milliseconds (\verb~ticks~).\\\\
\textbf{clockDelayUntil(clockServerID, time)} - Delays a task until the \textit{Clock Server} reports that [10 millisecond] tick \verb~time~ has passed. This method is implemented using calls to \verb~clockTime()~ and \verb~clockDelayBy~ and is therefore more susceptible to error.\\\\

The clock server is first instantiated by the initial task at priority 1 (one level short of the highest possible priority). It has the responsibility of: creating the clock notifier (at priority 0), handling delay requests, unblocking tasks whose delay time has passed. The notifier is at a priority higher than the server to ensure that the ‘tick’ interrupt is handled without blocking any other driver interaction; this model is useful in future parts of the project where various interrupts will compete for operation.

The clock server must be as responsive as possible in order to service the timer reliably for user tasks. \textit{BurritOS} implements a sorted linked-list data structure to facilitate fast dequeuing of delayed tasks. A task that wishes to delay a certain number of ticks is enqueued in the list in sorted order. Additionally, each node in the list retains a count of how many ticks to delay relative to its parent. This structure has the property of requiring the clock server to only decrement the head of the list during an uneventful timer tick. It is trivial to observe that a ‘dequeue’ tick occurs when the linked list has a set of nodes at the head with 0. The worst-case cost occurs during insertion with $O(n)$. Retrieval is at worst $O(k)$ where $k$ is the number of tasks that dequeued in one tick. During an uneventful tick (no dequeue operation), the cost is constant (decrement and check the head).

The primitives the clock server exposes to user tasks include: \verb~clockDelayBy~, \verb~clockTime~, \verb~clockDelayUntil~. \verb~clockDelayUntil~ is implemented as a function of the other two primitives for the purpose of this assignment. The other primitives wrap messages to the clock server. \verb~clockTime~ is replied to as soon as possible. \verb~clockDelayBy~ is replied to when the delay time has passed, unblocking the task in real-time.

The notifier is a simple ‘await-send’ loop. A more complicated architecture - courier and warehouse - was not used for this assignment since our message passing mechanism is fast and therefore we expect a simple architecture to provide reasonable response time. The notifier does have the additional task of killing the \textit{Clock Server} cleanly during system shutdown.

\subsubsection{Hardware I/O Servers: Terminal}

\textbf{printf(formatString, ...)} - A partial implementation of the C standardized \verb~printf~. It is does not wait until the output has been flushed.\\\\
\textbf{getc()} - Blocks and consumes a character from the \textit{Terminal Server}. Only one task should use this as the input is not duplicated for each task.\\\\

We chose to implement a slightly different interface for input/output than the kernel specification discusses. We deemed it costly to use \verb~putc~ directly since we generate long strings of text at specific locations using cursor commands. To accomodate this requirement, we implement \verb~putStr~ which sends whole strings to the \textit{Terminal Server}. This is used by userspace \verb~printf~ implementation in order to reduce the number of system calls and messaging overhead.

The terminal server architecture is as simple as possible. The server creates two notifiers: one for input and one for output. The server also maintains buffers for both input and output. Originally we designed a more elaborate structure (warehouse-courier model) to handle high bandwidth but observed that this structure was unnecessary given our messaging round-trip time.

\subsubsection{Hardware I/O Servers: Train}

\textbf{trainStop(trainServer)} - Commands the board to send an emergency stop to the track.\\\\
\textbf{trainGo(trainServer)} - Sends a Go to the track.\\\\
\textbf{trainSetSpeed(trainServer, train, speed)} - Sets a train to a given speed.\\\\

The input and output components of the train are implemented as one I/O server. Complexity was introduced as needed for the sensors. This was for performance reasons. Since the train UART is slow, we would like to send requests for a group of sensors. Unfortunately, that means tasks would send requests for more data than they’d need. Instead we choose to have a sensor server which buffers all the sensor data as fast as it can while passing along specific sensor information when clients request it.

Tasks will almost never directly talk to the \textit{Train Server} and instead will go through another more job specific server for the command they are sending. For example, a \textit{Train Switch Server} for throwing a switch.

\subsection{Tasks - Milestone 1}
Milestone 1 provides the ability to track the position of a single train on the track. This includes ensuring the train can stop at an arbitrary point on the track. We chose to stop the train only at sensors using a methodology that easily generalizes to arbitrary points on the track graph.

\subsubsection{Switch Office}
The \textit{Switch Office} (server) maintains a calendar which, in a sense, represents temporal ownership of a given switch. The server handles allocations to throw a switch into a given state at a given time and rejects invalid allocations --- i.e. a switch that was thrown into a state by someone else in that period. In order to facilitate requests effectively, the server spawns workers that utilize the \textit{Clock Service} to throw a switch at the allocated block of time.

This feature is not important and has been deprecated for the project.

\subsubsection{Train Commander}
\label{sec:traincommander}
The train commander fields commands from the command line input to train tasks. Every train dispatches a \textit{Locomotive Radio} courier to register a particular train ID with the \textit{Train Commander}. This model permits a train to block input to itself but not to other trains.

\subsubsection{Locomotive Task}
Every train is controlled by a single task, known as the \textit{Locomotive}, whose purpose is to create and facilitate communication between useful jobs. For this milestone, this consists of: commanding the train (through command input), positioning information, and prediction.

The \textit{Locomotive} creates the following subsystems:
\begin{itemize}
    \item{ \textit{Locomotive Radio}: Courier that transfers commands from central \textit{Train Commander}. These are commands entered in the command prompt.}
    \item{ \textit{Physics Tick}: A notifier that provides a reasonably reliable physics integration timestep. Used by the \textit{Locomotive} to calculate stopping distance through numerical integration of the (current) velocity. }
\end{itemize}

The current revision of the project does not attempt to break up the \textit{Locomotive} task into sub-processes. The task maintains a (large) state variable that is modified through a number of sub-operations. The operations are: time stepping, prediction, and sensor update. Sensor updating simply just updates the current sensor if it is owned by the locomotive. Prediction is usually dispatched following that, and involves caches the next possible sensors. Time stepping - the largest component - consists of stepping physics, allocating track, and avoiding trains.

The reason for this change in thinking is to reduce the likelihood of races. If two processes are tracking the same train, changes in direction need to propogate effectively and on time otherwise unexpected (and incorrect) behaviour may result.

\subsection{Tasks - Milestone 2}
Milestone 2 extends from the previous milestone by adding additional functionality to the Train tasks. The major (though simple) change involved adding track ownership. All other modifications extend from track ownership by simply considering which train owns what track piece. Our policy to prevent collisions simply requires that we can calculate the stopping distance of any train and allocate track ahead. Once this requirement is met, trains (the \textit{Locomotive} task) must only work with track nodes (branches, sensors) that they own. As long as all trains follow these policies, they cannot possibly collide. It is easy to show that any operation that violates these policies will likely lead to a system failure.

\subsubsection{Track Ownership}

\textbf{trainAllocateTrack(train, requestList)} - Revokes any previous allocation and attempts to allocate a new set of nodes to the train. Assumes the list be a contiguous sequence of nodes in the graph. On failure, the previous allocation is not revoked! \\\\
\textbf{trainWhoOwnsTrack(nodeId)} - Asks the \textit{Track Manager} which train owns the track node specified. \\\\

Track ownership is stored by an independent server known as the \textit{Track Manager}. The \textit{Track Manager} does not provide any protection to prevent ownership issues (such as leap-frogging) but instead provides a framework that supports ownership policies. That is, it serves as a central location to perform and store ownership information. The server provides an interface that permits a \textit{Locomotive} to allocate a sequence of nodes (path) atomically. Any allocation is preceded by a full revocation of all nodes owned by the requestor train. This gives the \textit{Locomotive} task freedom to only consider nodes it needs instead of those that it may have used in the past. This operation is atomic with respect to the \textit{Track Manager} ensuring that all contiguous path requests will remain contiguous.

\subsubsection{Locomotive Task - Path Finding}
Path finding is not treated as a separate task and is instead treated as an operation in the \textit{Locomotive}. The Dijkstra Algorithm is used to find the shortest path from any given node to any other node. It is performed at every sensor hit easily handling failed branches or a missed target sensor. Reverse path finding is not performed yet.

Path finding doesn't modify the branch state of the board since this can cause conflicts with other trains. Instead, as part of the ownership task of the train, the \textit{Locomotive} switches branches that it owns to the correct configuration. It uses physics calculations to determine whether the branch can be switched in time. If it cannot, path finding will be performed again at the next sensor and the \textit{Locomotive} will attempt a new approach towards the target sensor.

\subsubsection{Locomotive Task - Sensor Attribution}
Sensor attribution extends from the previous milestone by, once again, simply looking at the node ownership. Since the \textit{Locomotive} task owns nodes (instead of just branches, or edges), the \textit{Locomotive} can determine if the train actually should consider itself at a given sensor. Under the assumption that trains only travel on track they own, a fired sensor must be caused by the train that owns that sensor. Any other situation describes a context in which tracking of trains has failed.

\subsubsection{Locomotive Task - Collision Avoidance}
Collision avoidance simply uses track ownership, as described in the \textit{Track Manager}. The \textit{Locomotive} always attempts to allocate enough track ahead of its current position that permits it to stop with some extra room. If there is a conflict (i.e. a failure to allocate track), the \textit{Locomotive} task stops the train and then delays for a random amount.

The random amount is placed in order to give a chance for one train to own track in the reverse direction and reduce the chance of a long-lasting live-lock. If the train can reallocate after this time has passed, it then resumes in the same direction. Otherwise, the train will reverse and try again.

\subsection{Tasks - Project}

\subsubsection{Player Locomotive}
General user code did not change substantially in the feature set. Instead, the project consisted of a significant refactoring of the \textit{Locomotive} task. Removing the \textit{Locomotive GPS} (a task that independently tracked the position of a train) simplified the code and let us refactor the \textit{Locomotive} into easy to use sub-methods.

Due to this simplification of the \textit{Locomotive} task, creating a user controlled locomotive was not a significant amount of work. It simply required the creation of another whose locomotive state is modified slightly to indicate that it should not be automatically directed unless a collision is imminent. Unfortunately time did not permit fixing the bugs involved with automatic/user train-train interation. 

\subsection{User Interface}
\subsubsection{Layout and Control}
The text display is separated into three main regions: the input prompt, and two UI task slots. The prompt contains system summary information, such as the running time and idle performance, and looks something like the following:
\begin{verbatim}
[10:15.1 | 98.54%] > 
\end{verbatim}

The prompt occupies the entire first line of the display, and one line below the prompt is reserved for printing information about failed command inputs.

User tasks that have been added to the user interface task list can be displayed in one of the UI slots. Each slot is 23 characters tall, and fills the entire horizontal screen width. When a task is assigned to a slot, the main display task will send it a message containing the screen index that it can draw to. A second message containing an index of 0 is sent when the UI task should stop drawing, usually due to a different UI task replacing it. The UI tasks are switched with the \textit{su [slot] [task]} command. For example, to display UI task one in the first slot: \textit{su 0 1}.

UI task must provide their own mechanism for determining when to redraw/refresh the display - there is no global UI refresh rate. Some UI tasks, such as the ownership display, refresh at a fixed rate of 100ms. Others refresh only when new data is found, such as the sensor display. Most tasks have an initialization block that prints the majority of the contents, such as ASCII art output, and smaller update routines that print individual components of the UI.

A collection of display tasks are included the system, primarily for debugging train and track state. The tasks and their IDs are as follows:
\begin{verbatim}
Sensor Display          0
Switch Display          1
Ownership Display       2
Performance Summary     3
Process Summary         4
Log Server              5
Stack Summary           6
Project UI              7
Taco Logo               8
\end{verbatim}
\subsubsection{Sensor Display}

The sensor display task uses the sensor attribution to server to provide visual updates each time a train triggers a sensor. The sensor direction is also display, using the $<$ and $>$ symbols. A sample ASCII output from the sensor display is shown below. Dots ($.$) indicate untriggered sensors. The sensor task also provides a rolling list of the past sensor triggers, as well as a train ID for each of the sensors in the list. Output is colorized to distinguish between train IDs.

\begin{verbatim}
______.______._____________________<___    
_____._/ /___.________.___.________.___\ 
  __._/ //           \     /           \\.
       //            .\ | /.           .\\ 
       |v             .\|/.              |  
       |                |                |   
       |.             ./|\.              |   
  _.__ \\            ./ | \.           .// 
_.__._\ \\___._______/.___.\_______.___//.
_.___._\ \___.____>___________.____>___/  
_.____._\______._\_____________/_.__________
\end{verbatim}

The task works by spawn a second helper task to poll the sensor server for changing sensors. The sensor attribution server is then used to determine the owner of the sensor nodes, after which a UI update is triggered. The relavent sensors are then redrawn in bulk by the main display task.

\subsubsection{Switch Display}
The switch display shows the current state of the switches on the track, as shown below. Gaps indicate that a switch has been toggled. When running on the hardware, switch task output is bolded and colorized to improve readability. Additionally, a table of switches next to the ASCII output shows the current state of all 22 switches on the track.

\begin{verbatim}
______________________________________
_______/  /                           \
  ____/  ______________________________\
        /            \     /            \
       /              \ | /              \
       |               \|/               |
       |                |                |
       |               ||\               |
       \              / | \              /
  _____ \____________/_____\____________/
_______\ \_____________________________/
________\        \               /
_________\______________________/____________
\end{verbatim}

The switch task works in a similar way as the sensor display, however it uses a simpler polling model. A secondary polling task is used to check the state of all 22 switches every ~450 millseconds. After the switch state is polled a UI is redraw is triggered. Since there are only 22 switches, a naive poll/read model worked fine in practice.

\subsubsection{Ownership Display}

The ownership display task prints a colorized output that indicates the owner of each node in the track. There are a total of 72 distinct nodes - 40 sensors, 22 branches and 10 end pieces. A large ASCII diagram is used to display all of the nodes. The $@$ symbol is used to represent an end segment, $*$ represents a sensor and $\#$ represents a branch.

\begin{verbatim}
@______*________*_____________________*__
@____*___/#  /#                          \
@__*____/#  /#__*________*___*________*__#\
           /           #\     /#           \*
          /             *\ @ /*            *\
         |*              *\|/*              |
         |                #|#               |
         |                 |                |
         |                #|#               |
         |*              */|\*              |
          \             */ @ \*            */
@_*_____   \#___*______#/*___*\#______*___#/*
@_*__*__\#  \___*____*___________*____*___/
@_*___*__\#        \#             #/  
@_*____*__\#______*_\#___________#/_*_________@
\end{verbatim}

The ownership process holds a read-only pointer to the main ownership graph, as well as its own local copy of the graph. Every 100ms it checks the graph to see if anything has changed between its local copy and the main copy; if anything has, an update is triggered for that entry in the graph.

\subsubsection{Performance Summary}

The performance display shows the performance of each task in the system, updated at a 2.5 second refresh rate. The output of the task is the same as the example discussed in \textbf{Section 3.6}. It is intended to be used in conjunction with the idle task performance to debug infinite loops or excessive computation in user space tasks.

\subsubsection{Process Summary}

The process display task shows various information about all of the tasks in the system. This includes the name, id, send queue length, and various register values like the PC, LR and SP. It also lists the state of the process, such as Ready or SendBlocked. To make sure the process summary is able to reflect the system state as best as possible, it runs at the highest priority level. This causes it to take up a larger portion of CPU time than most processes - it takes between ten and fifteen percent when attached to a UI slot.

The process display can be scrolled up and down using the arrow keys, provided the UI slot it is displayed in has focus.

\subsubsection{Log Server}

The log server display task shows a rolling buffer of log messages. Each message has a timestamp attached to it that shows the time the message was received. The \textit{logMessage(fmt, ...)} utility method can be used to write a formatted message to the log server.

\subsubsection{Stack Summary}

The stack summary displays information about the stack blocks used by tasks, and reports the total number of blocks still remaining in the system. Since the blocks can also be acquired using \textit{sysAlloc}, the total block count is useful for debugging.

The task displays the current stack pointer, base stack pointer, stack usage and stack block if for each of the running tasks in the system. The usage is computed from the SP and BSP, and will therefore be incorrect if the task writes to arbitrary locations on its stack.

Stack overflows can easily be found using the stack display, since all memory blocks are 64kB. Additionally, the reported stack block id will not match the expected stack block id, since the id is used as canary at the base of each stack.

\subsubsection{Project UI}

The project UI displays the game the player has to complete. The game involves manually driving a train around the track using the arrow keys to control speed and branch direction. The goal is to hit all of the sensors in the random list on the screen.

\subsubsection{Taco Logo}

The taco logo is a useless UI task that simple prints a happy taco ASCII art to the screen.

\begin{verbatim}
....................
....................
......______ .......
...../      \ \.....
..../  ^  ^  \n\....
...|          hn|...
...|  \____/  hn|...
....\_________\/....
....................
......burritOS......
....................
\end{verbatim}

\subsection{Prompt Commands}
\begin{verbatim}
q                   Cleanly shutdown the system
k                   Forcibly kill the system

la [id]             Launch train #id for calibration
lg [id]             Launch train #id for player control (final project)
tr [id][speed]      Set train #id to a target #speed
rv [id]             Reverse train #id
rm [id]             Flip train direction without sending rv

gt [id][sensor]     Drive train #id to #sensor
sa [id][sensor]     Drive train #id to #sensor and stop

sw [id][C|S]        Set branch #id to curved or straight

su [slot][id]       Set UI #slot to use display task #id
fu [slot]           Set UI #slot to received arrow key input focus
\end{verbatim}

\section{Train Modeling}

\subsection{Static Model}
A variety of data collection experiments were performed when developing the physical model for the trains. This included starting distance, stopping distance, inter-speed acceleration and steady state velocity. Only the steady-state velocity and stopping distance were used for the first demo, since the train didn't need to change speeds. Error in tracking from the lack of starting acceleration model was ignored during the demo.

For the steady state velocity, a one-to-one mapping of train speed to velocity was produced. For example, the following map was used for Train 62:
\begin{verbatim}
    Speed  5   ->   224376 um/mt
    Speed  6   ->   275931 um/mt
    Speed  7   ->   335343 um/mt
    Speed  8   ->   389936 um/mt
    Speed  9   ->   441837 um/mt
    Speed 10   ->   491406 um/mt
    Speed 11   ->   541752 um/mt
    Speed 12   ->   589662 um/mt
    Speed 13   ->   632801 um/mt
\end{verbatim}

The units on the velocity are micrometers per megatick. Since we used the 983 Khz timer it was easiest to perform the calculations in ticks rather than in seconds. The computations were done using fixed point integers, hence the use of micrometers instead of millimeters.

Note that speeds 1 - 4, and 14 were ignored. We found that speeds below 5 were too slow to reliably tranverse the track without getting stuck at dead zones. Speed 14 produced strange behavior for some of the trains. For example, for Train 62 it had the same velocity as speed 13, but a different acceleration profile.

Modeling acceleration was done by mapping all valid speeds, including 0, to all other possible speeds. This required a 10x10 mapping array. The acceleration functionality was not used during the Trains 1 demo, however an example acceleration table for Train 62 is listed below:

\begin{verbatim}
    Speed 5 ->  0       -113256 um/mt^2
    Speed 5 ->  5             0 um/mt^2
    Speed 5 ->  6         92468 um/mt^2
    Speed 5 ->  7        177639 um/mt^2
    Speed 5 ->  8        192717 um/mt^2
    Speed 5 ->  9        205884 um/mt^2
    Speed 5 -> 10        213830 um/mt^2
    Speed 5 -> 11        237231 um/mt^2
    Speed 5 -> 12        255761 um/mt^2
    Speed 5 -> 13        252275 um/mt^2
\end{verbatim}

The units on the accelerations are micrometers per megatick squared.

The actual stopping distance calcuation in the Trains 1 Demo code is hacked together, since we had to switch trains at the last minute. As such, the \textit{trainPhysicsStopDist} method directly computes the stopping distance rather than going through the proper table lookups. This computation also takes into account overshoot by adding a factor of $v*60ms$.

\subsection{Dynamic Model}

Run time corrections are made to the model to improve accuracy. During the first ten sensor triggers the velocity model is updated to account for any discrepencies between the train and the static model. On subsequent sensor triggers, any timing error was stored on the sensor node so that future predictions could account for it. The assumption was that in most cases, if the train was late to a sensor once it would have a decent chance of being late again.

The combination of the static model and run time corrections to the dynamic model was sufficiently accurate for the demo. We were generally able to stop the train within a few centimeters of the target location and accurate predict the arrival time at sensors with less than 30ms of error.

\section{File Listings}
The following listing contains the name and hash of all of the source files in the current project:
\begin{verbatim}
4bb8b1b57ce3bb774a4a1797376558be  common/common.h
dbc1e1f655ec2eb5634d253a4e225901  common/error.h
2d19eb27d9841b9d69477d156070414d  common/heap.c
4599b661bc0cd5b2794afbd41e1186c7  common/heap.h
21fb2c280e2237066cc8bef5d08c7a03  common/list.c
0b6cd0ee4dab7252e4fc056e9d4cb8d3  common/list.h
0a75e9ea015602357e05992d269d1cae  common/memcpy.h
4ad96714a59e326dd08f49fa87ac8edf  common/memcpy.s
65491591f39cd860d49c262b3541a11e  common/memset.c
06d14c9b85a344d1794fd1de3aca1cc1  common/memset.h
adcf35544f06b19164f55b953995d1ff  common/priorityQueue.c
5111780c98f90c807e28c9051a957bd1  common/priorityQueue.h
9a51fd55cbaa0561763a09336f2a2eea  common/queue.c
7a570500eaaa3aaece0e2c3ab932806c  common/queue.h
839e67159271fe8335ef3f12755443f0  common/random.c
f989ae83d0f804388cdc9cbaa41a95f5  common/random.h
51f48f7fffd96b988d0d424119850596  common/string.c
0eb10e8842dc414bcd499341a23cc5db  common/string.h
1aca0ab83913d5a7432db2ce8b3e46b4  common/timerState.h
a7d11483d9452d5d8f9f784bb26e8209  common/types.h
7884ba72dbec8e0e3a09a2193cc1cd6c  common/utils.h
7fdf99d4a9ea148c4e8d4d8b2777404d  common/vaList.h

4541004aefa37b3c3e19d8c184deb2f6  hardware/hardware.h
98f10a0ba0008da70ef80f36cd2a9031  hardware/interrupt.h
c71fbd7b3723c4bf4d0d104902b01487  hardware/memory.h
6c5930b3f894fe526814ea0ce188ed4e  hardware/timer.h
d5f38025b527f774835847d5f79ad85b  hardware/uart.h
87306d757b7eda3d725cad19dc6bf919  hardware/ts7200/interrupt.c
4b8ad1779a2c1b2c7c767a76d067e160  hardware/ts7200/start.s
20421e2c6a4e0d22bce2d9c812680b34  hardware/ts7200/timer.c
6055b18f1d4b2f2d6a200ff8cbcbeebf  hardware/ts7200/ts7200.h
ac2247029448237de4c4590f27698a85  hardware/ts7200/vector.s
4e90444ef3fbdfb1078e8682dee3084e  hardware/ts7200/uart.c

b9ccd6cc031e6d339d7bc7bd18f7f895  kernel/assert.c
caac750f901b606a3b2f951f3483d091  kernel/assert.h
4a430452391bb23bc62269efbb62e01f  kernel/config.h
74845107469cf4a11eb30e63ccedb531  kernel/bootstrap.c
59e283c66c5a66e627e33f3ef39a6f58  kernel/event.c
26f5ecdbe74ff55fddc97b6127cee60e  kernel/event.h
027b87b518651720441978c985804ce4  kernel/kernel.h
8169ff0345038b3337e244491a014d07  kernel/kernelData.c
f6c4b6303c324dcfecf1e6333b7ba02c  kernel/kernelData.h
f8a30fe67fb0ab3ae7905cf429aaf5a0  kernel/kernelUtils.h
c1b8f89e01d797c5b606726807ac6e4b  kernel/kernelUtils.s
90c960ca087068eee38a437ca5bcade2  kernel/memoryAllocator.c
ce2a6a86fe62bb049d321d96d23d1f79  kernel/memoryAllocator.h
269831580f0cb96b0128c175c677d590  kernel/message.h
7617ed11988f83aa8440410517efd7f7  kernel/print.c
6a21b1817843435936a212ce8f594f85  kernel/print.h
a3481d9f6370bbb1f2697f969a8738c0  kernel/scheduler.c
e5a0f5cd21d6a62a1f5eb64d6731cb0a  kernel/systemCall.c
0369200d137568c474242afc9ae8325e  kernel/systemCall.h
a3fbd89f67cd9802ec0ee5d04234b0fd  kernel/taskDescriptor.h
adb7b4908e283ef35ee8cbb1a5dd40ad  kernel/taskTable.c
e46bc116c4450befc0c0260ca9a7b0d2  kernel/taskTable.h

80a2f12e7e8b279566bcb5aa9604288e  trains/train58.h
5b3c0f265f184d7e95a1b8bedff3c1b4  trains/train62.h
0d838afb51970bbd49f6e934eb8a581b  trains/train64.h
fdd798504c0c09e1690671c7fc655142  trains/train68.h
f052165bf1d5c1e8873f1c219f7e967c  trains/train69.h
f38476700a9274f63e197ac17de4ae04  trains/train70.h
35cb22a2ad726e5826e1f9939098f967  trains/trains.h
7db7a1caaeb62879ba800f5fda5f3269  trains/trackData.c
5a817f17542a9ca277a0e38779eff468  trains/trackData.h
ba00aee82786403eb2c0d44e03a0cb47  trains/trackGraph.c
874ca00be75e9da06367e24843222759  trains/trackGraph.h
d714607ad4bf6ec1a6916ae0d12805d7  trains/trainInit.h
1161c63d1c0f24c6f1b4c173d39d750d  trains/trainMath.h
a51fee6be16c32e8298b2e8d6739cd3f  trains/trackNode.h
5aade30da22831a74472ccc885dd5285  trains/trainPhysics.c
a27b71aaf12f636e641b2725814dd006  trains/trainPhysics.h

846c211c0c81867b597479a31249c940  user/messageTypes.h
a01d7f95458f44436a20e7ffc626b890  user/IdleTask.c
e7ff85ba8f14ce99e0229fff7dd87d52  user/IdleTask.h
7e54d15044b007076d6dfff7520ebf12  user/InitialTask.c
63bb9b7bc6d198c30c328b2f2e0850f8  user/InitialTask.h

8efa0d5f277ba74a8e8d38c0cb7918ba  user/display/DigitalClockDisplay.c
8b58af96d06a52275d686e4f172ff3f6  user/display/DigitalClockDisplay.h
9b2a9792b29d4263af112239b8812d94  user/display/HydroDisplay.c
782bbd0bf5431fe3d85dcc6de7d7cb34  user/display/HydroDisplay.h
113e3b392cce650717fd3e628859a81d  user/display/IdlePerformanceDisplay.c
821497be16c6603ca5787db3c01c2417  user/display/IdlePerformanceDisplay.h
002c280d3f0380b0a326be483632f44c  user/display/LogDisplay.c
8fd9d818e9059d91bb4a02f915e4a2c7  user/display/LogDisplay.h
4f4a4cc9af1a84d48304c1dbe0a09b24  user/display/OwnerDisplay.c
aec4776c794cac90c28b22c8d7f8bbf6  user/display/OwnerDisplay.h
4c30b858d97746fbeabb5856230f4360  user/display/PerformanceDisplay.c
046f035fbbd7081ce01790317e495379  user/display/PerformanceDisplay.h
03c0ca956a468672136d1bdfa26010eb  user/display/ProcessDisplay.c
dfdac70e7d826b7e2150e5ee9b2f6917  user/display/ProcessDisplay.h
3e5ddd3ba389e6be396645e95005de3d  user/display/ProjectDisplay.c
0392d45ae772bcd52b6d9d47ea276149  user/display/ProjectDisplay.h
2916c957e092265cab94b96657194121  user/display/PromptDisplay.c
886ba450f91dfc7e80becb1a71d208cf  user/display/PromptDisplay.h
85fe1774ce5d3ee516d523081c7bc848  user/display/SensorDisplay.c
f720cb5f7c54893a176e1ffb53a53845  user/display/SensorDisplay.h
662e5706298c19a0d1f83e50927343c4  user/display/StackDisplay.c
75d3a8ec12b8f8b912db9e2ff9954bcf  user/display/StackDisplay.h
8650a1a7feea4382d6c781481dbdfee5  user/display/SwitchDisplay.c
ed96aad50758f00249b6acc3ed6010b2  user/display/SwitchDisplay.h
9b6c7a3066eebee04925ed99b49a1c54  user/display/TacoDisplay.c
d98a03a75c12e9db847fe90204ef14c4  user/display/TacoDisplay.h

1c77c18014d4834bf7d8cc1e110f3639  user/servers/ClockNotifier.c
fda7de6c69066a709f71851d409038c8  user/servers/ClockNotifier.h
93ed2a02895f1d29dab0196a920fd51f  user/servers/ClockServer.c
368242d16e123c6910bce9bbd9be9cd0  user/servers/ClockServer.h
5ce850a0ca90fbba0277955dfc8d74db  user/servers/NameServer.c
7c8d6a256a3bd5ee748c79806a3e2225  user/servers/NameServer.h
837561ccb4cf9e92498560553dc02e8c  user/servers/TerminalDriver.c
6fd529e84ccf8f4264e0c9d22870e626  user/servers/TerminalDriver.h
27bcb2dece95d683ec269f593e25d7e2  user/servers/TrainDriver.c
b1228054cb0be753d947d59480718fa5  user/servers/TrainDriver.h
748bca682d4ef266161f9193821f8c08  user/servers/TrainSensorServer.c
4187f9f4987b2058fb8d86696503c6ed  user/servers/TrainSwitchServer.c

c56436accee020788546e56ff0a8cc32  user/services/clockService.c
db36bdd1dc6ef57eb26049aa6fe1e45a  user/services/clockService.h
b1d37cb42c79cdaa0b5728477f5dad9b  user/services/nameService.c
f4e8a3efb3776eb335448bd66ab39c26  user/services/nameService.h
cbb0a6db7a3fa6c7758e2907aa62e831  user/services/services.c
9abbea9cf81b40755d6176a08bb9cc73  user/services/services.h
1e6b2ef9fdfc03566fed88f76a8bba03  user/services/terminal.c
4151fe7addc8b8f120cee58f886832d2  user/services/terminal.h
e56c99c4d12c2d3323a2189f5a28d9ab  user/services/trainCommand.c
396ee7e3ab6ac2f220e0fda6f4432d81  user/services/trainCommand.h

7134217e5a46d741e7510c5b49fc97f7  user/trainservers/trains.c
27f1ceba9fd6a96ee341608130834ed2  user/trainservers/trainservers.h
0585a41c4f2266581df0a7361f44c314  user/trainservers/trainservices.h
eecfde480a70358c86d15715978443f0  user/trainservers/Locomotive.c
3702aae0ac910f3914e83e7487f3fa60  user/trainservers/Locomotive.h
1d63eea78916bcf599efca0c38799f7a  user/trainservers/locomotiveState.c
177a4c766b08dfefdbff1552a707fc91  user/trainservers/PlayerLocomotive.c
bab56d41af31194bef8696683f95fc85  user/trainservers/SwitchOffice.c
d831166af2f3ddc79d042e05fc67992e  user/trainservers/SwitchOffice.h
7d3e1af21999ceafc802808348da720e  user/trainservers/TrainCommander.c
7a35d1a942d01548f0074a8bccab2a9a  user/trainservers/TrainCommander.h
874d89e65f3e063fbee15c79ed106c4c  user/trainservers/TrainYard.c
94b7fa2046faaba2d46baa3fbf5edcd7  user/trainservers/TrainYard.h
08a2a728a2f46d014ab93f971c230fa2  user/trainservers/TrackManager.c
a0d9ba883788bfe3e888e46171b9e58e  user/trainservers/TrackManager.h
\end{verbatim}
\end{document}
