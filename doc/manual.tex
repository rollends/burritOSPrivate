\documentclass[twoside,a4paper]{refart}
\usepackage{makeidx}
\usepackage{ifthen}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\def\bs{\char'134 }
\newcommand{\ie}{i.\,e.,}
\newcommand{\eg}{e.\,g..}
\DeclareRobustCommand\cs[1]{\texttt{\char`\\#1}}
\settextfraction{0.9}
\setlength\parskip {0.15in}

\title{burritOS System Manual}
\author{Rollen D'Souza (20418141) \\
rs2dsouz@uwaterloo.ca \\
Taylor Petrick (20413951) \\
tpetrick@uwaterloo.ca \\}

\date{\textbf{CS 452 - Trains Demo 1 \\ \today}}
\emergencystretch1em  %

\pagestyle{myfootings}
\markboth{burritOS System Manual}%
         {burritOS System Manual}

\makeindex
\setcounter{tocdepth}{2}
\begin{document}
\maketitle

Changes summary....

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin pulvinar euismod ipsum, quis egestas sem cursus eget. Morbi dignissim porttitor vehicula. Vestibulum iaculis, odio eget sagittis luctus, lectus magna iaculis sem, non rhoncus lorem urna id dui. Etiam augue lacus, ullamcorper vel orci ut, tempus semper leo. Praesent malesuada mauris dolor, et laoreet est ullamcorper at. Suspendisse tincidunt semper euismod. Sed ac vulputate lorem. Pellentesque lectus justo, suscipit at velit et, finibus aliquam libero.

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut sed placerat neque. Ut ornare diam a bibendum egestas. Phasellus quis venenatis odio, ac consequat eros. Sed condimentum mauris et dolor tempor commodo. Vivamus eu ex metus. Ut suscipit dui orci, sit amet ornare magna auctor facilisis. Morbi id feugiat metus.

Nam luctus odio at luctus hendrerit. Mauris molestie, purus quis maximus rhoncus, massa purus auctor felis, ac venenatis ex nunc ut arcu. Nam luctus, tellus non tempus ornare, turpis mi finibus sapien, ut bibendum ante risus sed metus. Sed porta nec turpis sit amet accumsan. Maecenas accumsan consectetur nisl, id pellentesque urna. Mauris vel fringilla velit, semper interdum magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent ac tempor sem, a cursus purus. In id dui quis lectus ultricies pellentesque. Nunc eget tincidunt dolor. Curabitur placerat pulvinar ex, at maximus diam ultricies vitae. Quisque sit amet tempor mi.

\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compiling and Running}
A compiled version of our Trains 1 submission can be found in the following directory on the student environment:
\begin{center}
\textit{/u/cs452/tftp/ARM/tpetrick/t1.elf}\\
\textit{md5 hash: ?}
\end{center}
The source code for our submission has been shared with the CS 452 TA via the UW GitLab, and can be accessed at the following URL:
\begin{center}
\url{https://git.uwaterloo.ca/tpetrick/CS452_Project}\\
\textit{md5 hash: ?}
\end{center}
Additionally, the course code can also be downloaded as an archive from Taylor’s personal web server:
\begin{center}
\url{https://www.taylorpetrick.com/cs452/t1.tar.gz}\\
\textit{md5 hash: ?}
\end{center}
Both source code locations contain the files listed in the File Listings section of this report.

To compile the source code, simply run \textit{make} in the top level source directory. This will produce the binary file \textit{/bin/t1.elf}, which should be identical to the elf file listed above. Running \textit{make clean} will remove all build output files, and \textit{make doc} will generate documentation from the source files if Doxygen is installed on the system.

By default, code is built using a unity build technique. The makefile runs \textit{cat} on all of the source files to produce a single source file, which is then built with GCC. This can be disabled by passing \textit{UNITY=0} when running \textit{make}.

The file can be loaded and run on the TS7200 board with the following Redboot commands:

\textit{\textgreater load -b 0x50000 -h 10.15.167.5 /u/cs452/tftp/ARM/tpetrick/k4.elf}\\
\textit{\textgreater go}\\\\

\textbf{CAUTION:}  The load address has changed since our past submissions. We no longer use the default address of \textit{0x218000}, and require that code is loaded at \textit{0x50000} instead. This should be handled automatically by the linker script and \textit{.elf} file, however it may be necessary to specify the \textit{-b} parameter when loading to Redboot.

\section{Common Libraries}
\subsection{Type Interface}
The types used by both kerenl and user space are defined in \textit{common/types.h}
\subsection{Data Structures}
\subsection{Utilities}

\section{General Purpose User Tasks}
The general purpose user-space tasks provide important services on top of the kernel. All of these tasks provide a named interface that can be discovered using the \textit{Name Server}. The \textit{Name Server} is assumed to be have a task ID of 2.

\subsection{Name Service}

\subsubsection{Interface}
\textbf{nsRegister(taskName)} - Registers the caller task with the name provided.\\\\
\textbf{nsWhoIs(taskName)} - Looks up the \verb~TaskID~ of the task registered with the provided name. Will block until \textit{all} task names have been registered.

\subsubsection{Implementation}
The \textit{Name Server} task triages and responds requests to find the task ID of a \'named\' task. Two service methods are provided as the interface to the name service. This service provides the ability for tasks to find other operating system services. The current implementation requires that all possible registrations be made before any lookup (WhoIs) requests are served. As a consequence of our kernel development tenets, we chose enumerated values to represent task names instead of strings. This reduces complexity in the user space code of the nameserver. An enumerated list has a well-defined maximum meaning the nameserver can maintain a constant-sized array to store registered IDs.

\subsection{Clock Service}

\subsubsection{Interface}
\textbf{clockDelayBy(clockServerID, ticks)} - Delays a task by \verb~ticks~ times 10 milliseconds. The delay is guaranteed to an interval of plus or minus 10 milliseconds.\\\\
\textbf{clockLongDelayBy(clockServerID, longTicks)} - Delays a task by \verb~longTicks~ times 150 milliseconds. The delay is guaranteed to an interval of plus or minus 150 milliseconds.\\\\
\textbf{clockTime(clockServerID)} - Returns the current time reported by the \textit{Clock Server}, in multiples of 10 milliseconds (\verb~ticks~).\\\\
\textbf{clockDelayUntil(clockServerID, time)} - Delays a task until the \textit{Clock Server} reports that [10 millisecond] tick \verb~time~ has passed. This method is implemented using calls to \verb~clockTime()~ and \verb~clockDelayBy~ and is therefore more susceptible to error.

\subsubsection{Implementation}
The clock server is first instantiated by the initial task at priority 1 (one level short of the highest possible priority). It has the responsibility of: creating the clock notifier (at priority 0), handling delay requests, unblocking tasks whose delay time has passed. The notifier is at a priority higher than the server to ensure that the ‘tick’ interrupt is handled without blocking any other driver interaction; this model is useful in future parts of the project where various interrupts will compete for operation.

The clock server must be as responsive as possible in order to service the timer reliably for user tasks. \textit{BurritOS} implements a sorted linked-list data structure to facilitate fast dequeuing of delayed tasks. A task that wishes to delay a certain number of ticks is enqueued in the list in sorted order. Additionally, each node in the list retains a count of how many ticks to delay relative to its parent. This structure has the property of requiring the clock server to only decrement the head of the list during an uneventful timer tick. It is trivial to observe that a ‘dequeue’ tick occurs when the linked list has a set of nodes at the head with 0. The worst-case cost occurs during insertion with $O(n)$. Retrieval is at worst $O(k)$ where $k$ is the number of tasks that dequeued in one tick. During an uneventful tick (no dequeue operation), the cost is constant (decrement and check the head).

The primitives the clock server exposes to user tasks include: \verb~clockDelayBy~, \verb~clockTime~, \verb~clockDelayUntil~. \verb~clockDelayUntil~ is implemented as a function of the other two primitives for the purpose of this assignment. The other primitives wrap messages to the clock server. \verb~clockTime~ is replied to as soon as possible. \verb~clockDelayBy~ is replied to when the delay time has passed, unblocking the task in real-time.

The notifier is a simple ‘await-send’ loop. A more complicated architecture - courier and warehouse - was not used for this assignment since our message passing mechanism is fast and therefore we expect a simple architecture to provide reasonable response time. The notifier does have the additional task of killing the \textit{Clock Server} cleanly during system shutdown.

\subsection{Hardware I/O Servers: Terminal}

\subsubsection{Interface}
\textbf{printf(formatString, ...)} - A partial implementation of the C standardized \verb~printf~. It is does not wait until the output has been flushed.\\\\
\textbf{getc()} - Blocks and consumes a character from the \textit{Terminal Server}. Only one task should use this as the input is not duplicated for each task.

\subsubsection{Implementation}
We chose to implement a slightly different interface for input/output than the kernel specification discusses. We deemed it costly to use \verb~putc~ directly since we generate long strings of text at specific locations using cursor commands. To accomodate this requirement, we implement \verb~putStr~ which sends whole strings to the \textit{Terminal Server}. This is used by userspace \verb~printf~ implementation in order to reduce the number of system calls and messaging overhead.

The terminal server architecture is as simple as possible. The server creates two notifiers: one for input and one for output. The server also maintains buffers for both input and output. Originally we designed a more elaborate structure (warehouse-courier model) to handle high bandwidth but observed that this structure was unnecessary given our messaging round-trip time.

\subsection{Hardware I/O Servers: Train}

\subsubsection{Interface}
\textbf{trainStop(trainServer)} - Commands the board to send an emergency stop to the track.\\\\
\textbf{trainGo(trainServer)} - Sends a Go to the track.\\\\
\textbf{trainSetSpeed(trainServer, train, speed)} - Sets a train to a given speed.

\subsubsection{Implementation}
The input and output components of the train are implemented as one I/O server. Complexity was introduced as needed for the switches and sensors. The switches need delays of 160ms between every command. In order to implement this, we took advantage of the courier design. An independent switch server handles switch requests. This switch server creates a courier that communicates to the actual train I/O server. The trick is to implement a delay inside the courier, hiding the delay from both servers and, more importantly, from any other request that may come to the train server (set speed, reverse). This model also allows the switch server to easily determine when to send a turn-off-solenoid request; this event fires when the courier arrives at the switch server without any pending switch commands.

Complexity was introduced in sensor reading for performance reasons. Since the train UART is slow, we would like to send requests for a group of sensors. Unfortunately, that means tasks would send requests for more data than they’d need. Instead we choose to have a sensor server which buffers all the sensor data as fast as it can while passing along specific sensor information when clients request it.

Tasks will almost never directly talk to the \textit{Train Server} and instead will go through another more job specific server for the command they are sending. For example, a \textit{Train Switch Server} for throwing a switch.

\section{Hardware Interface}
\subsection{General Notes and Usage}
\subsection{Interrupt Driven I/O}
The \textit{sysWrite} call takes a UART port and character as parameters and blocks the calling task until a transmit interrupt occurs. Since transmit interrupts continuously fire until a byte is transmitted, we disable the interrupt on the UART after transmitting a byte. \textit{sysWrite} also enables the TX interrupt so the task will be able to send data.

A \textit{sysRead} call is also provided for reading from a serial port. The call takes a UART port as its only parameter and returns a byte once an RX interrupt occurs on the desired UART. Technically sysRead could be implemented using the existing \textit{sysAwait}, however we chose to make a separate system call for readability and API consistency. Initially we also experimented with buffering input in the kernel, which required special read/write logic - the names \textit{sysRead}/\textit{sysWrite} calls are leftover from that implementation.

When using UART 1 the CTS flag is checked before transmitting data. This is done by handling the ORed interrupt for UART 1, which includes RX, TX and modem status interrupts. When a UART 1 interrupt occurs we first determine which source (RX, TX, Modem) it is by reading the UART’s IRQ status register. If a modem status interrupt is triggered, the interrupt handler queries the UART’s CTS register and updates the kernel’s CTS flag. If the interrupt is an RX or TX interrupt, the event table is checked to see if any tasks are waiting to read or write from UART 1. TX interrupts are only processed for UART 1 if the CTS flag is set to 1 UART 2 does not require a CTS flag, so the ORed interrupt trigger isn’t used. The event handler processes the raw TX and RX interrupts for that UART in the same way that the timer events are handled.

\section{Kernel Design}

\subsection{Memory Layout}
Task stacks are placed at address \textit{0x01000000} and higher. Task stacks are created in 16kb blocks. The stacks are managed by a \textit{MemoryAllocator} that uses FIFO queues to give out and reclaim stack blocks. The first word on the stack is its block id; the remaining space is used by the task as desired. Storing the id to the stack serves a dual purpose - it makes reclaiming the stack easier, and also act as an indicator for stack overflows. A block id that seems corrupted when the stack is reclaimed by the allocator is a strong indication that a neighboring stack overflowed.

The system has more memory blocks that tasks, so the additional blocks can be access by tasks using the \textit{sysAlloc()} and \textit{sysFree()} calls. These methods also return \textit{16kb} blocks, and serve as a basic memory page allocator.

\subsection{Data Structures}
All data structures in our implementation fall into two categories: flat arrays and circular queues. The circular queues are implemented using a memory block, a length variable and head/tail indices indicating the start and end of the queue. The length and memory pointer are passed in when the queue is initialized. This allows the size of the queue to vary based on the context (e.g. small send queues but large ready queues). Our kernel requires that queues have a length that is equal to a power of two. This is to avoid using modulus function from libgcc. Instead, since the queues are a power of two in length, a bitwise \textit{and} can be used to ensure the queue indices wrap around to 0. For example:

\begin{verbatim}
head = (head + 1) & (length - 1)
\end{verbatim}

The priority queue used for scheduling of ready tasks is a special data structure that contains a set of circular buffer queues. One queue is used for each of the priorities. Kernel 1 and 2 only used three priorities, however in Kernel 3 the number of priorities was increased to 32. A 32 bit integer is used to determine which queues have tasks in them. Bit twiddling is done to compute the highest priority queue with an element in it; the code to do this was taken from \url{https://graphics.stanford.edu/~seander/bithacks.html}. It emulates a count trailing zeroes (CTZ) instruction since ARM v4 lacks CTZ/CLZ.

TaskDescriptors (or otherwise known as TDs) contain the information the kernel needs to schedule tasks and perform system calls. Non essentially information such as the PC and SPSR are stored on the task stack. The kernel stores a TaskTable which has a fixed size array of task descriptors and queue of free descriptors. At the start of the kernel, all descriptors are in the free queue. When a task is created, it pops from the queue and uses the available task descriptor. When a task exits it returns the descriptor to the queue so it can be reused later on. A generation id is stored along with each task id, and gets incremented each time a task is reclaimed by the TaskTable. The TD recycling feature is not used for Kernel 1, but it is included in the code since we plan to build on it in future assignments

TDs themselves are designed to be tightly packed. Task priority is stored as a single byte rather than a full 32 bit value, for example. TaskIDs are 16 bit values, where the first byte is the generation number and second byte is the actual task id and index into the TaskDescriptor array. The task ids are one-based, since task 0 will eventually be used to identify the null process. At the moment, our kernel is defined to support a maximum of 64 tasks. It can support as many as 255 tasks and 255 generations, however it seems unlikely that we will come close to either of these values.

The last important data structure is the kernel data struct. Kernel data is stored as a global that is only used in  kernel functions (bootstrap, schedule and system call). It contains the task table, a pointer to the active task descriptor and the priority queue and queue data.

\subsection{Control Flow}
The bulk of the kernel logic is controlled in the assembly file \textit{kernel/start.s}. The kernel begins by initializes the interrupt vector table. It then calls the \textit{bootstrap()} function, which initializes all of the kernel data structures and creates the first user task. The user task is entered and runs until an SWI instruction is executed.

When a system call is made the program branches to the \textit{\_systemCall} label in \textit{kernel/start.s}. Since the \textit{SWI} call is wrapped in a C function, GCC automatically places the parameters into \textit{R0-R3} and onto the user stack. To minimize the amount of memory overhead, the system call is processed almost immediately after entering the SWI handler. This is done by calling \textit{systemCallHandler()}, which is performed in System Mode so the user stack is available. The return value from the function is stored in \textit{R0} by GCC. After the call completes the user registers are stacked, including the new \textit{R0} value. When the user task registers are unstacked the next time the task runs, the \textit{R0} value will be restored so the task can inspect the system call return value.

After stacking the registers the kernel calls \textit{schedule()} which updates the task descriptor of the current task, re-enqueues it if necessary and selects a new task from the priority queues. The new task’s stack pointer is returned and the task is entered, thus repeating the process. If the new stack pointer is 0 the kernel will branch to the \textit{kernelEnd} handler to perform cleanup and exit the program.

When an interrupt is fired the control flow is very similar. The interrupt causes the code to jump to the \textit{\_interruptCall} label, which is very similar to \textit{\_systemCall} discussed above. The primary difference is that the interrupt handler calls the  \textit{interruptHandler()} C function instead of processing a system call. The other functionality, such as stacking user registers and scheduling a new task, is the same.

It is worth noting that the task registers are stored in the following layout on the task stack:

\begin{verbatim}
stack+0x0       SPSR
                Task LR (R14)
                R0
                R4
                ..
                R12
stack+0xA       Task PC (R15)
\end{verbatim}
This somewhat out-of-order stacking order was chosen to make the context switcher more compact.

\subsection{Event Handling}
The \textit{sysAwaitEvent(event)} primitive allows tasks to wait for interrupts. The supported events are defined in \textit{kernel/event.h}. The kernel data struct has a table that maps event types to the task ids waiting on the events. Only one task can wait on an event at a time, which we think will be sufficient for the remaining coursework.

When an interrupt occurs the system jumps to the label \textit{\_interruptCall}. This works much like the swi handler, however instead of calling the syscall function it calls \textit{interruptHandler()} to process the interrupt. The interrupt handler checks the event table to see if a task is waiting on the event. If a valid task id is found, the task is unblocked and the table entry cleared, otherwise the interrupt is consumed without taking any additional action. Like the swi handler, an interrupt results in a call to the scheduler after interrupt processing is complete.

\subsection{Message Passing}
Messages can be set between tasks using the \textit{sysSend} and \textit{sysReceive} system calls, both of which are blocking. After receiving a message a task must reply to its sender using the \textit{sysReply} primitive.

By default, no deep memory copies are done in the kernel. All messages are at most 1 word in length, however that word can be a pointer to a large buffer of memory if desired. When the kernel sends a message it copies the message type and the 1 word message body to the receiver’s message envelope. It is up to the receiving task to make a copy of the memory using the \_memcpy function. This design makes the kernel extremely lightweight, and also eliminates the need to do a memory copy if the message data is used in a read-only way. For safety reasons, this design is unsuitable for general purpose operating systems, but in a control RTOS it offers performance benefits.

For the performance benchmarks with 64 bytes a full memcpy is done upon receiving a message and after receiving a reply. The memcpy implementation was written from scratch and uses load/store multiple instructions to improve copying speed.

\subsection{Performance}
Performance timing is reset with a call to \textit{sysPerfReset()} - this sets all task performance counters to 0 and resets the timer used by the kernel to track performance. The kernel uses the 40-bit debug timer for this process since it’s clocked at around 983 Khz. This offers slightly better timer resolution that the standard 16 and 32 bit timers, which can only run at a max of 508 Khz.

Calling \textit{sysPerfQueryP(tid, mode)} will return the percentage of execution time spent on the task tid. The mode parameter can be \textit{ePerfKernel}, \textit{ePerfTask} or \textit{ePerfBoth}. Using \textit{ePerfKernel} returns the time spent by the task in the kernel, and \textit{ePerfTask} returns the time spent in task code. The \textit{ePerfBoth} option is useful be cause it adds the kernel and task performance together before computing the percentage - this yields slightly higher precision results in most cases since the numerator of the computation is larger.

The \textit{sysPerfQueryT(tid, mode)} system call queries the run time microseconds for each of the cases listed above, rather than as a relative percentage. Additionally the mode value ePerfTotal can be passed in to get the total run time in microseconds since the last call to \textit{sysPerfReset()}.

The performance timings are implemented by storing two unsigned integers at the end of each task descriptor. When a system call or interrupt occurs, the active task has its task mode counter updated by the current timer delta. Then, right before the scheduler returns, the last active task has its kernel mode counter updated by the timer delta. Both updates reset the timer delta. This means that task mode timings are the amount of time spent from the return statement of the scheduler until the entry point of a system call or interrupt, and kernel mode timings are the amount of time spent inside the syscall/interrupt and scheduler. This is not a perfect representation of task/kernel time, but is close enough to be useful.

The following output was produced using the data recored by the performance primitives:
\begin{verbatim}
    TaskId  Tsk %   Krnl %  Ttl %   Tsk us      Krnl us     Ttl us
    0x00    46.17   50.68   96.86   1,156,700   1,269,741   2,426,442
    0x01    00.26   00.00   00.26       6,623          64       6,687
    0x02    00.00   00.00   00.00          28          43          72
    0x03    00.03   00.05   00.10       1,053       1,509       2,563
    0x04    00.03   00.05   00.10       1,075       1,539       2,614
    0x05    01.21   00.00   01.22      30,915          91      31,012
    0x06    01.22   00.00   01.22      31,209         114      31,324
    0x07    00.55   00.00   00.55      14,049          57      14,107
    0x08    00.36   00.00   00.36       9,366          42       9,408
    0x09    00.17   00.00   00.17       4,691          26       4,718

    Total run time: 2,552,806us ~ 2.552s
\end{verbatim}

\section{System Calls}
\subsection{System State}

The \textit{System State} calls are used to monitor the state of the kernel. Currently there are two calls in this category.

\textbf{sysRunning(void)} - Returns 1 if the system running flag is set, else returns 0.\\\\
\textbf{sysShutdown(void)} - Sends a shutdown signal to the kernel, and sets the running state to 0. Does not force the system to terminate; processes must check the running flag with \textit{sysRunning} to determine if they should continue executing.

\subsection{Task Management}

\textit{Task Management} system calls are used to create, destroy and query tasks. There are a total of 7 task related system calls.

\textbf{sysExit(void)} - Exits a task and returns the descriptor and stack back to the kernel. This system call is deprecated; tasks will perform this operation on their own once the task function returns.\\\\
\textbf{sysPass(void)} - Yields control of the processor to the kernel. Effective performs a no-op, however since the scheduler is invoked a different task may be entered.\\\\
\textbf{U16 = sysCreate(priority, entry\_point)} - Creates a new task with a given priority and code entry point. The new task's id is returned.\\\\
\textbf{char* = sysName(tid)} - Returns a pointer to the string name of a given task.\\\\
\textbf{U16 = sysTid(void)} - Returns the id of the current task.\\\\
\textbf{U16 = sysPid(void)} - Returns the id of the current task's parent.\\\\
\textbf{U8 = sysPriority(void)} - Returns the priority of the current task.

\subsection{Messaging}

\textit{Messaging} system calls are used to perform inter-task communication. Currently only blocking ITC is supported.

\textbf{sysSend(tid, *msg, *reply)} - Sends a message to task, and provides a memory location in which the reply should be stored. Blocks the caller until a \textit{sysReply} is sent by the receiver.\\\\
\textbf{sysReceive(*tid, *msg)} - Receives a message and stores the sender id and message body. Blocks the caller until a message arrives.\\\\
\textbf{sysReply(tid, *msg)} - Sends a reply message back in response to a \textit{sysReceive}.

\subsection{Performance}

The \textit{Performance} calls are used to monitor system performance. See Section 4.6 for details on performance monitoring.

\textbf{sysPerfReset(void)} - Resets performance tracking on all tasks.\\\\
\textbf{sysPerfQueryP(tid, mode)} - Queries performance of task for a given mode, as a percentage of total runtime.\\\\
\textbf{sysPerfQueryT(tid, mode)} - Queries performance of task for a given mode, as an absolute time in microseconds.

\subsection{Event Handling and I/O}

\textit{Event} system calls are used to block on hardware interrupts and interact with hardware peripherals. See the Hardware section for details on interrupt driven input and output. All Event calls cause tasks to be blocked on hardware interrupts.

\textbf{sysAwait(event)} - Blocks the calling task on a specific event.\\\\
\textbf{char = sysRead(port)} - Blocking read from a UART port.\\\\
\textbf{sysWrite(port, byte)} - Blocking write to a UART port.

\subsection{Memory}

The burritOS system does not use or provide heap allocation, however it does have a generic memory block allocator. The allocator is used to give out stack blocks; extra blocks are available via memory system calls. No protection or ownership verification is done on the blocks.

\textbf{U32* = sysAlloc(void)} - Returns a pointer to a 16kB - 1 word memory block. The first address holds the block id, so the memory returned begins after that location.\\\\
\textbf{sysFree(block*)} - Frees a memory block pointer for reuse by the system.

\section{Debugging and Assertions}
 Almost all hardware and kernel functions return a status code and perform safety checks including out-of-bounds access, invalid memory addresses and invalid parameter values. Assertions are used liberally to validate both kernel and user-space code. When an assertion is throw, a debug message is printed:

\begin{verbatim}
....................
....................
......______ .......
...../      \\......
..../  x  x  \\.....
...|   ____   h|....
...|  /    \  h|....
....\_________\/....
....................
.....SAD..TACO......
....................
Assertion in `kernel/scheduler.c` on line 18
Current Active Task is 0x06
\end{verbatim}

Assertions, return codes and bounds checking can be enabled/disabled using a collection of preprocessor flags. When return codes are disabled functions return void, otherwise they return a signed integer. These flags are:\\
\begin{verbatim}
NULL_CHECK              Include null pointer checks on memory address
BOUNDS_CHECK            Include bounds checking
RANGE_CHECK             Include memory address range checks
DEVICE_CHECK            Include device register checks (e.g. UART, timers, etc)
ASSERT_BUILD            Enabled assertions
RETURN_CODES            Enable return codes
KERNEL_PERF             Enable kernel performance primitives
KERNEL_PERF_VERBOSE     Enable verbose performance updates from the perf Task
\end{verbatim}

These flags enable a set of error and assertion macros that are normally disabled. For example, for null checking:

\begin{verbatim}
#ifdef NULL_CHECK
    #define IS_NOT_NULL(x) do {if ((x) == 0) return ERROR_NULL;} while(0);
#else
    #define IS_NOT_NULL(x)
#endif
\end{verbatim}

It is up to the kernel programmer to use the macros in their code, so we have not yet achieved full coverage. This is an area that will be improved in future iterations of the kernel.
\section{Userspace}
\subsection{Services}
\subsection{Tasks}

\section{Known Issues}
\section{File Listings}

\printindex

\end{document}
